- Suma Modular.
  * R0: x (+m) 0 = x
  * RS: x (+m) s(y) = s(x (+m) y), donde s es el sucesor modular.

- Deutsch-Josza (DJ). El programa P toma un oráculo para una función f: {0,1}^n -> {0,1} que es constante (P -> 1) o bien es equilibrada (P -> 0).
  * Sean g un automorfismo de {0,1}^n y f una función como la del enunciado, se cumple que P(f) = P(f(g)).
  * Dada f: {0,1}^n -> {0,1} una función constante o equilibrada, siempre se verifica que P(f) = P(1 - f).
  * Sean f una función f como la del enunciado y f' otra función que resulta de mantener fijos la mitad de 0's e intercambiar la otra mitad de 0's por 1's.
    De forma análoga, f' no afecta a la mitad de valores x para los que f(x) = 1 y para el resto de esos valores se tiene f'(x) = 0.
    Al considerar esta nueva función, resultado de perturbar exactamente la mitad de asignaciones de f, se tiene que P(f') = 1 para cualquier f escogida.
    
- Bernstein-Vazirani (BV). Dada una función f_s = s*x (mod 2), el programa P nos devolverá el valor de la cadena de bits s.
  * De forma general, dada una función g: {0,1}^m x {0,1}^n -> {0,1}^p, siempre se verificará que P(f_g(s,t)) = g(P(f_s),P(f_t)).
    1. Si t es la cadena resultante de aplicar X (0 -> 1, 1 -> 0) bit a bit en s, entonces P(f_(s+t)) = |1...1⟩.
    2. P(f_(s+t)) = P(f_s) + P(f_t).
    3. P(f_(s*t)) = P(f_s) * P(f_t).
